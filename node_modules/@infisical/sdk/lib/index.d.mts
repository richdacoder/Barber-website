import { AxiosRequestConfig } from 'axios';
import { z } from 'zod';

declare enum SecretType {
    Shared = "shared",
    Personal = "personal"
}
interface Secret {
    id: string;
    workspaceId: string;
    environment: string;
    secretKey: string;
    secretValue: string;
    secretComment?: string;
    secretPath?: string;
    secretValueHidden: boolean;
    secretReminderNote?: string;
    secretReminderRepeatDays?: number;
    skipMultilineEncoding?: boolean;
    folderId?: string;
    actor?: {
        actorId?: string;
        name?: string;
        actorType?: string;
        membershipId?: string;
    };
    isRotatedSecret: boolean;
    rotationId?: string;
    secretMetadata?: Record<string, any>;
    type: SecretType;
    createdAt: string;
    updatedAt: string;
    version: number;
    tags: string[];
}
interface ListSecretsRequest {
    workspaceId: string;
    environment: string;
    expandSecretReferences?: string;
    include_imports?: string;
    recursive?: string;
    secretPath?: string;
    tagSlugs?: string;
    viewSecretValue?: string;
}
interface ListSecretsResponse {
    secrets: Secret[];
    imports?: Array<{
        secretPath: string;
        secrets: Secret[];
        folderId?: string;
        environment: string;
    }>;
}
interface GetSecretRequest {
    secretName: string;
    workspaceId: string;
    environment: string;
    expandSecretReferences?: string;
    includeImports?: string;
    secretPath?: string;
    type?: SecretType;
    version?: number;
    viewSecretValue?: string;
}
interface GetSecretResponse {
    secret: Secret;
}
interface CreateSecretRequest {
    workspaceId: string;
    environment: string;
    secretValue: string;
    secretComment?: string;
    secretPath?: string;
    secretReminderNote?: string;
    secretReminderRepeatDays?: number;
    skipMultilineEncoding?: boolean;
    tagIds?: string[];
    type?: SecretType;
}
interface UpdateSecretRequest {
    workspaceId: string;
    environment: string;
    secretValue?: string;
    newSecretName?: string;
    secretComment?: string;
    secretPath?: string;
    secretReminderNote?: string;
    secretReminderRepeatDays?: number;
    skipMultilineEncoding?: boolean;
    tagIds?: string[];
    type?: SecretType;
    metadata?: Record<string, any>;
}
interface DeleteSecretRequest {
    workspaceId: string;
    environment: string;
    secretPath?: string;
    type?: SecretType;
}
type ListSecretsOptions = {
    environment: string;
    projectId: string;
    expandSecretReferences?: boolean;
    attachToProcessEnv?: boolean;
    includeImports?: boolean;
    recursive?: boolean;
    secretPath?: string;
    tagSlugs?: string[];
    viewSecretValue?: boolean;
};
type GetSecretOptions = {
    environment: string;
    secretName: string;
    expandSecretReferences?: boolean;
    includeImports?: boolean;
    secretPath?: string;
    type?: SecretType;
    version?: number;
    projectId: string;
    viewSecretValue?: boolean;
};
type BaseSecretOptions = {
    environment: string;
    projectId: string;
    secretComment?: string;
    secretPath?: string;
    secretReminderNote?: string;
    secretReminderRepeatDays?: number;
    skipMultilineEncoding?: boolean;
    tagIds?: string[];
    type?: SecretType;
    metadata?: Record<string, any>;
    secretMetadata?: Record<string, any>[];
};
type UpdateSecretOptions = {
    secretValue?: string;
    newSecretName?: string;
} & BaseSecretOptions;
type CreateSecretOptions = {
    secretValue: string;
} & BaseSecretOptions;
type DeleteSecretOptions = {
    environment: string;
    projectId: string;
    secretPath?: string;
    type?: SecretType;
};

interface ApiClientConfig {
    baseURL: string;
    headers?: Record<string, string>;
    timeout?: number;
}
declare class ApiClient {
    private client;
    constructor(config: ApiClientConfig);
    private setupRetryInterceptor;
    setAccessToken(token: string): void;
    get<T>(url: string, config?: AxiosRequestConfig): Promise<T>;
    post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;
    patch<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;
    delete<T>(url: string, config?: AxiosRequestConfig): Promise<T>;
}

interface UniversalAuthLoginRequest {
    clientId: string;
    clientSecret: string;
}
interface UniversalAuthLoginResponse {
    accessToken: string;
    expiresIn: number;
}
interface AwsIamAuthLoginRequest {
    identityId: string;
    iamHttpRequestMethod: string;
    iamRequestBody: string;
    iamRequestHeaders: string;
}
interface AwsIamAuthLoginResponse {
    accessToken: string;
    expiresIn: number;
}
interface TokenRenewRequest {
    accessToken: string;
}
interface TokenRenewResponse {
    accessToken: string;
    expiresIn: number;
}

declare enum SqlProviders {
    Postgres = "postgres",
    MySQL = "mysql2",
    Oracle = "oracledb",
    MsSQL = "mssql",
    SapAse = "sap-ase"
}
declare enum ElasticSearchAuthTypes {
    User = "user",
    ApiKey = "api-key"
}
declare enum LdapCredentialType {
    Dynamic = "dynamic",
    Static = "static"
}
declare enum TotpConfigType {
    URL = "url",
    MANUAL = "manual"
}
declare enum TotpAlgorithm {
    SHA1 = "sha1",
    SHA256 = "sha256",
    SHA512 = "sha512"
}
declare enum DynamicSecretProviders {
    SqlDatabase = "sql-database",
    Cassandra = "cassandra",
    AwsIam = "aws-iam",
    Redis = "redis",
    AwsElastiCache = "aws-elasticache",
    MongoAtlas = "mongo-db-atlas",
    ElasticSearch = "elastic-search",
    MongoDB = "mongo-db",
    RabbitMq = "rabbit-mq",
    AzureEntraID = "azure-entra-id",
    Ldap = "ldap",
    SapHana = "sap-hana",
    Snowflake = "snowflake",
    Totp = "totp",
    SapAse = "sap-ase"
}
declare const DynamicSecretProviderSchema: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
    type: z.ZodLiteral<DynamicSecretProviders.SqlDatabase>;
    inputs: z.ZodObject<{
        client: z.ZodNativeEnum<typeof SqlProviders>;
        host: z.ZodString;
        port: z.ZodNumber;
        database: z.ZodString;
        username: z.ZodString;
        password: z.ZodString;
        creationStatement: z.ZodString;
        revocationStatement: z.ZodString;
        renewStatement: z.ZodOptional<z.ZodString>;
        ca: z.ZodOptional<z.ZodString>;
        passwordRequirements: z.ZodOptional<z.ZodObject<{
            length: z.ZodNumber;
            required: z.ZodObject<{
                minUppercase: z.ZodOptional<z.ZodNumber>;
                minLowercase: z.ZodOptional<z.ZodNumber>;
                minDigits: z.ZodOptional<z.ZodNumber>;
                minSymbols: z.ZodOptional<z.ZodNumber>;
            }, "strip", z.ZodTypeAny, {
                minUppercase?: number | undefined;
                minLowercase?: number | undefined;
                minDigits?: number | undefined;
                minSymbols?: number | undefined;
            }, {
                minUppercase?: number | undefined;
                minLowercase?: number | undefined;
                minDigits?: number | undefined;
                minSymbols?: number | undefined;
            }>;
            allowedSymbols: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            length: number;
            required: {
                minUppercase?: number | undefined;
                minLowercase?: number | undefined;
                minDigits?: number | undefined;
                minSymbols?: number | undefined;
            };
            allowedSymbols?: string | undefined;
        }, {
            length: number;
            required: {
                minUppercase?: number | undefined;
                minLowercase?: number | undefined;
                minDigits?: number | undefined;
                minSymbols?: number | undefined;
            };
            allowedSymbols?: string | undefined;
        }>>;
    }, "strip", z.ZodTypeAny, {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        client: SqlProviders;
        database: string;
        renewStatement?: string | undefined;
        ca?: string | undefined;
        passwordRequirements?: {
            length: number;
            required: {
                minUppercase?: number | undefined;
                minLowercase?: number | undefined;
                minDigits?: number | undefined;
                minSymbols?: number | undefined;
            };
            allowedSymbols?: string | undefined;
        } | undefined;
    }, {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        client: SqlProviders;
        database: string;
        renewStatement?: string | undefined;
        ca?: string | undefined;
        passwordRequirements?: {
            length: number;
            required: {
                minUppercase?: number | undefined;
                minLowercase?: number | undefined;
                minDigits?: number | undefined;
                minSymbols?: number | undefined;
            };
            allowedSymbols?: string | undefined;
        } | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    type: DynamicSecretProviders.SqlDatabase;
    inputs: {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        client: SqlProviders;
        database: string;
        renewStatement?: string | undefined;
        ca?: string | undefined;
        passwordRequirements?: {
            length: number;
            required: {
                minUppercase?: number | undefined;
                minLowercase?: number | undefined;
                minDigits?: number | undefined;
                minSymbols?: number | undefined;
            };
            allowedSymbols?: string | undefined;
        } | undefined;
    };
}, {
    type: DynamicSecretProviders.SqlDatabase;
    inputs: {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        client: SqlProviders;
        database: string;
        renewStatement?: string | undefined;
        ca?: string | undefined;
        passwordRequirements?: {
            length: number;
            required: {
                minUppercase?: number | undefined;
                minLowercase?: number | undefined;
                minDigits?: number | undefined;
                minSymbols?: number | undefined;
            };
            allowedSymbols?: string | undefined;
        } | undefined;
    };
}>, z.ZodObject<{
    type: z.ZodLiteral<DynamicSecretProviders.Cassandra>;
    inputs: z.ZodObject<{
        host: z.ZodString;
        port: z.ZodNumber;
        localDataCenter: z.ZodString;
        keyspace: z.ZodOptional<z.ZodString>;
        username: z.ZodString;
        password: z.ZodString;
        creationStatement: z.ZodString;
        revocationStatement: z.ZodString;
        renewStatement: z.ZodOptional<z.ZodString>;
        ca: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        localDataCenter: string;
        renewStatement?: string | undefined;
        ca?: string | undefined;
        keyspace?: string | undefined;
    }, {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        localDataCenter: string;
        renewStatement?: string | undefined;
        ca?: string | undefined;
        keyspace?: string | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    type: DynamicSecretProviders.Cassandra;
    inputs: {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        localDataCenter: string;
        renewStatement?: string | undefined;
        ca?: string | undefined;
        keyspace?: string | undefined;
    };
}, {
    type: DynamicSecretProviders.Cassandra;
    inputs: {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        localDataCenter: string;
        renewStatement?: string | undefined;
        ca?: string | undefined;
        keyspace?: string | undefined;
    };
}>, z.ZodObject<{
    type: z.ZodLiteral<DynamicSecretProviders.SapAse>;
    inputs: z.ZodObject<{
        host: z.ZodString;
        port: z.ZodNumber;
        database: z.ZodString;
        username: z.ZodString;
        password: z.ZodString;
        creationStatement: z.ZodString;
        revocationStatement: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        database: string;
    }, {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        database: string;
    }>;
}, "strip", z.ZodTypeAny, {
    type: DynamicSecretProviders.SapAse;
    inputs: {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        database: string;
    };
}, {
    type: DynamicSecretProviders.SapAse;
    inputs: {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        database: string;
    };
}>, z.ZodObject<{
    type: z.ZodLiteral<DynamicSecretProviders.AwsIam>;
    inputs: z.ZodObject<{
        accessKey: z.ZodString;
        secretAccessKey: z.ZodString;
        region: z.ZodString;
        awsPath: z.ZodOptional<z.ZodString>;
        permissionBoundaryPolicyArn: z.ZodOptional<z.ZodString>;
        policyDocument: z.ZodOptional<z.ZodString>;
        userGroups: z.ZodOptional<z.ZodString>;
        policyArns: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        secretAccessKey: string;
        region: string;
        accessKey: string;
        awsPath?: string | undefined;
        permissionBoundaryPolicyArn?: string | undefined;
        policyDocument?: string | undefined;
        userGroups?: string | undefined;
        policyArns?: string | undefined;
    }, {
        secretAccessKey: string;
        region: string;
        accessKey: string;
        awsPath?: string | undefined;
        permissionBoundaryPolicyArn?: string | undefined;
        policyDocument?: string | undefined;
        userGroups?: string | undefined;
        policyArns?: string | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    type: DynamicSecretProviders.AwsIam;
    inputs: {
        secretAccessKey: string;
        region: string;
        accessKey: string;
        awsPath?: string | undefined;
        permissionBoundaryPolicyArn?: string | undefined;
        policyDocument?: string | undefined;
        userGroups?: string | undefined;
        policyArns?: string | undefined;
    };
}, {
    type: DynamicSecretProviders.AwsIam;
    inputs: {
        secretAccessKey: string;
        region: string;
        accessKey: string;
        awsPath?: string | undefined;
        permissionBoundaryPolicyArn?: string | undefined;
        policyDocument?: string | undefined;
        userGroups?: string | undefined;
        policyArns?: string | undefined;
    };
}>, z.ZodObject<{
    type: z.ZodLiteral<DynamicSecretProviders.Redis>;
    inputs: z.ZodObject<{
        host: z.ZodString;
        port: z.ZodNumber;
        username: z.ZodString;
        password: z.ZodOptional<z.ZodString>;
        creationStatement: z.ZodString;
        revocationStatement: z.ZodString;
        renewStatement: z.ZodOptional<z.ZodString>;
        ca: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        host: string;
        port: number;
        username: string;
        creationStatement: string;
        revocationStatement: string;
        password?: string | undefined;
        renewStatement?: string | undefined;
        ca?: string | undefined;
    }, {
        host: string;
        port: number;
        username: string;
        creationStatement: string;
        revocationStatement: string;
        password?: string | undefined;
        renewStatement?: string | undefined;
        ca?: string | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    type: DynamicSecretProviders.Redis;
    inputs: {
        host: string;
        port: number;
        username: string;
        creationStatement: string;
        revocationStatement: string;
        password?: string | undefined;
        renewStatement?: string | undefined;
        ca?: string | undefined;
    };
}, {
    type: DynamicSecretProviders.Redis;
    inputs: {
        host: string;
        port: number;
        username: string;
        creationStatement: string;
        revocationStatement: string;
        password?: string | undefined;
        renewStatement?: string | undefined;
        ca?: string | undefined;
    };
}>, z.ZodObject<{
    type: z.ZodLiteral<DynamicSecretProviders.SapHana>;
    inputs: z.ZodObject<{
        host: z.ZodString;
        port: z.ZodNumber;
        username: z.ZodString;
        password: z.ZodString;
        creationStatement: z.ZodString;
        revocationStatement: z.ZodString;
        renewStatement: z.ZodOptional<z.ZodString>;
        ca: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        renewStatement?: string | undefined;
        ca?: string | undefined;
    }, {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        renewStatement?: string | undefined;
        ca?: string | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    type: DynamicSecretProviders.SapHana;
    inputs: {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        renewStatement?: string | undefined;
        ca?: string | undefined;
    };
}, {
    type: DynamicSecretProviders.SapHana;
    inputs: {
        host: string;
        port: number;
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        renewStatement?: string | undefined;
        ca?: string | undefined;
    };
}>, z.ZodObject<{
    type: z.ZodLiteral<DynamicSecretProviders.AwsElastiCache>;
    inputs: z.ZodObject<{
        clusterName: z.ZodString;
        accessKeyId: z.ZodString;
        secretAccessKey: z.ZodString;
        region: z.ZodString;
        creationStatement: z.ZodString;
        revocationStatement: z.ZodString;
        ca: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        creationStatement: string;
        revocationStatement: string;
        clusterName: string;
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
        ca?: string | undefined;
    }, {
        creationStatement: string;
        revocationStatement: string;
        clusterName: string;
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
        ca?: string | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    type: DynamicSecretProviders.AwsElastiCache;
    inputs: {
        creationStatement: string;
        revocationStatement: string;
        clusterName: string;
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
        ca?: string | undefined;
    };
}, {
    type: DynamicSecretProviders.AwsElastiCache;
    inputs: {
        creationStatement: string;
        revocationStatement: string;
        clusterName: string;
        accessKeyId: string;
        secretAccessKey: string;
        region: string;
        ca?: string | undefined;
    };
}>, z.ZodObject<{
    type: z.ZodLiteral<DynamicSecretProviders.MongoAtlas>;
    inputs: z.ZodObject<{
        adminPublicKey: z.ZodString;
        adminPrivateKey: z.ZodString;
        groupId: z.ZodString;
        roles: z.ZodArray<z.ZodObject<{
            collectionName: z.ZodOptional<z.ZodString>;
            databaseName: z.ZodString;
            roleName: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            databaseName: string;
            roleName: string;
            collectionName?: string | undefined;
        }, {
            databaseName: string;
            roleName: string;
            collectionName?: string | undefined;
        }>, "many">;
        scopes: z.ZodArray<z.ZodObject<{
            name: z.ZodString;
            type: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            type: string;
            name: string;
        }, {
            type: string;
            name: string;
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        roles: {
            databaseName: string;
            roleName: string;
            collectionName?: string | undefined;
        }[];
        adminPublicKey: string;
        adminPrivateKey: string;
        groupId: string;
        scopes: {
            type: string;
            name: string;
        }[];
    }, {
        roles: {
            databaseName: string;
            roleName: string;
            collectionName?: string | undefined;
        }[];
        adminPublicKey: string;
        adminPrivateKey: string;
        groupId: string;
        scopes: {
            type: string;
            name: string;
        }[];
    }>;
}, "strip", z.ZodTypeAny, {
    type: DynamicSecretProviders.MongoAtlas;
    inputs: {
        roles: {
            databaseName: string;
            roleName: string;
            collectionName?: string | undefined;
        }[];
        adminPublicKey: string;
        adminPrivateKey: string;
        groupId: string;
        scopes: {
            type: string;
            name: string;
        }[];
    };
}, {
    type: DynamicSecretProviders.MongoAtlas;
    inputs: {
        roles: {
            databaseName: string;
            roleName: string;
            collectionName?: string | undefined;
        }[];
        adminPublicKey: string;
        adminPrivateKey: string;
        groupId: string;
        scopes: {
            type: string;
            name: string;
        }[];
    };
}>, z.ZodObject<{
    type: z.ZodLiteral<DynamicSecretProviders.ElasticSearch>;
    inputs: z.ZodObject<{
        host: z.ZodString;
        port: z.ZodNumber;
        roles: z.ZodArray<z.ZodString, "many">;
        auth: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
            type: z.ZodLiteral<ElasticSearchAuthTypes.User>;
            username: z.ZodString;
            password: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            type: ElasticSearchAuthTypes.User;
            username: string;
            password: string;
        }, {
            type: ElasticSearchAuthTypes.User;
            username: string;
            password: string;
        }>, z.ZodObject<{
            type: z.ZodLiteral<ElasticSearchAuthTypes.ApiKey>;
            apiKey: z.ZodString;
            apiKeyId: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            type: ElasticSearchAuthTypes.ApiKey;
            apiKey: string;
            apiKeyId: string;
        }, {
            type: ElasticSearchAuthTypes.ApiKey;
            apiKey: string;
            apiKeyId: string;
        }>]>;
        ca: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        auth: {
            type: ElasticSearchAuthTypes.User;
            username: string;
            password: string;
        } | {
            type: ElasticSearchAuthTypes.ApiKey;
            apiKey: string;
            apiKeyId: string;
        };
        host: string;
        port: number;
        roles: string[];
        ca?: string | undefined;
    }, {
        auth: {
            type: ElasticSearchAuthTypes.User;
            username: string;
            password: string;
        } | {
            type: ElasticSearchAuthTypes.ApiKey;
            apiKey: string;
            apiKeyId: string;
        };
        host: string;
        port: number;
        roles: string[];
        ca?: string | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    type: DynamicSecretProviders.ElasticSearch;
    inputs: {
        auth: {
            type: ElasticSearchAuthTypes.User;
            username: string;
            password: string;
        } | {
            type: ElasticSearchAuthTypes.ApiKey;
            apiKey: string;
            apiKeyId: string;
        };
        host: string;
        port: number;
        roles: string[];
        ca?: string | undefined;
    };
}, {
    type: DynamicSecretProviders.ElasticSearch;
    inputs: {
        auth: {
            type: ElasticSearchAuthTypes.User;
            username: string;
            password: string;
        } | {
            type: ElasticSearchAuthTypes.ApiKey;
            apiKey: string;
            apiKeyId: string;
        };
        host: string;
        port: number;
        roles: string[];
        ca?: string | undefined;
    };
}>, z.ZodObject<{
    type: z.ZodLiteral<DynamicSecretProviders.MongoDB>;
    inputs: z.ZodObject<{
        host: z.ZodString;
        port: z.ZodOptional<z.ZodNumber>;
        username: z.ZodString;
        password: z.ZodString;
        database: z.ZodString;
        ca: z.ZodOptional<z.ZodString>;
        roles: z.ZodArray<z.ZodString, "many">;
    }, "strip", z.ZodTypeAny, {
        host: string;
        username: string;
        password: string;
        roles: string[];
        database: string;
        port?: number | undefined;
        ca?: string | undefined;
    }, {
        host: string;
        username: string;
        password: string;
        roles: string[];
        database: string;
        port?: number | undefined;
        ca?: string | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    type: DynamicSecretProviders.MongoDB;
    inputs: {
        host: string;
        username: string;
        password: string;
        roles: string[];
        database: string;
        port?: number | undefined;
        ca?: string | undefined;
    };
}, {
    type: DynamicSecretProviders.MongoDB;
    inputs: {
        host: string;
        username: string;
        password: string;
        roles: string[];
        database: string;
        port?: number | undefined;
        ca?: string | undefined;
    };
}>, z.ZodObject<{
    type: z.ZodLiteral<DynamicSecretProviders.RabbitMq>;
    inputs: z.ZodObject<{
        host: z.ZodString;
        port: z.ZodNumber;
        tags: z.ZodDefault<z.ZodArray<z.ZodString, "many">>;
        username: z.ZodString;
        password: z.ZodString;
        ca: z.ZodOptional<z.ZodString>;
        virtualHost: z.ZodObject<{
            name: z.ZodString;
            permissions: z.ZodObject<{
                read: z.ZodString;
                write: z.ZodString;
                configure: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                read: string;
                write: string;
                configure: string;
            }, {
                read: string;
                write: string;
                configure: string;
            }>;
        }, "strip", z.ZodTypeAny, {
            name: string;
            permissions: {
                read: string;
                write: string;
                configure: string;
            };
        }, {
            name: string;
            permissions: {
                read: string;
                write: string;
                configure: string;
            };
        }>;
    }, "strip", z.ZodTypeAny, {
        host: string;
        port: number;
        username: string;
        password: string;
        tags: string[];
        virtualHost: {
            name: string;
            permissions: {
                read: string;
                write: string;
                configure: string;
            };
        };
        ca?: string | undefined;
    }, {
        host: string;
        port: number;
        username: string;
        password: string;
        virtualHost: {
            name: string;
            permissions: {
                read: string;
                write: string;
                configure: string;
            };
        };
        ca?: string | undefined;
        tags?: string[] | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    type: DynamicSecretProviders.RabbitMq;
    inputs: {
        host: string;
        port: number;
        username: string;
        password: string;
        tags: string[];
        virtualHost: {
            name: string;
            permissions: {
                read: string;
                write: string;
                configure: string;
            };
        };
        ca?: string | undefined;
    };
}, {
    type: DynamicSecretProviders.RabbitMq;
    inputs: {
        host: string;
        port: number;
        username: string;
        password: string;
        virtualHost: {
            name: string;
            permissions: {
                read: string;
                write: string;
                configure: string;
            };
        };
        ca?: string | undefined;
        tags?: string[] | undefined;
    };
}>, z.ZodObject<{
    type: z.ZodLiteral<DynamicSecretProviders.AzureEntraID>;
    inputs: z.ZodObject<{
        tenantId: z.ZodString;
        userId: z.ZodString;
        email: z.ZodString;
        applicationId: z.ZodString;
        clientSecret: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        tenantId: string;
        userId: string;
        email: string;
        applicationId: string;
        clientSecret: string;
    }, {
        tenantId: string;
        userId: string;
        email: string;
        applicationId: string;
        clientSecret: string;
    }>;
}, "strip", z.ZodTypeAny, {
    type: DynamicSecretProviders.AzureEntraID;
    inputs: {
        tenantId: string;
        userId: string;
        email: string;
        applicationId: string;
        clientSecret: string;
    };
}, {
    type: DynamicSecretProviders.AzureEntraID;
    inputs: {
        tenantId: string;
        userId: string;
        email: string;
        applicationId: string;
        clientSecret: string;
    };
}>, z.ZodObject<{
    type: z.ZodLiteral<DynamicSecretProviders.Ldap>;
    inputs: z.ZodUnion<[z.ZodObject<{
        url: z.ZodString;
        binddn: z.ZodString;
        bindpass: z.ZodString;
        ca: z.ZodOptional<z.ZodString>;
        credentialType: z.ZodDefault<z.ZodOptional<z.ZodLiteral<LdapCredentialType.Dynamic>>>;
        creationLdif: z.ZodString;
        revocationLdif: z.ZodString;
        rollbackLdif: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        url: string;
        binddn: string;
        bindpass: string;
        credentialType: LdapCredentialType.Dynamic;
        creationLdif: string;
        revocationLdif: string;
        ca?: string | undefined;
        rollbackLdif?: string | undefined;
    }, {
        url: string;
        binddn: string;
        bindpass: string;
        creationLdif: string;
        revocationLdif: string;
        ca?: string | undefined;
        credentialType?: LdapCredentialType.Dynamic | undefined;
        rollbackLdif?: string | undefined;
    }>, z.ZodObject<{
        url: z.ZodString;
        binddn: z.ZodString;
        bindpass: z.ZodString;
        ca: z.ZodOptional<z.ZodString>;
        credentialType: z.ZodLiteral<LdapCredentialType.Static>;
        rotationLdif: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        url: string;
        binddn: string;
        bindpass: string;
        credentialType: LdapCredentialType.Static;
        rotationLdif: string;
        ca?: string | undefined;
    }, {
        url: string;
        binddn: string;
        bindpass: string;
        credentialType: LdapCredentialType.Static;
        rotationLdif: string;
        ca?: string | undefined;
    }>]>;
}, "strip", z.ZodTypeAny, {
    type: DynamicSecretProviders.Ldap;
    inputs: {
        url: string;
        binddn: string;
        bindpass: string;
        credentialType: LdapCredentialType.Dynamic;
        creationLdif: string;
        revocationLdif: string;
        ca?: string | undefined;
        rollbackLdif?: string | undefined;
    } | {
        url: string;
        binddn: string;
        bindpass: string;
        credentialType: LdapCredentialType.Static;
        rotationLdif: string;
        ca?: string | undefined;
    };
}, {
    type: DynamicSecretProviders.Ldap;
    inputs: {
        url: string;
        binddn: string;
        bindpass: string;
        creationLdif: string;
        revocationLdif: string;
        ca?: string | undefined;
        credentialType?: LdapCredentialType.Dynamic | undefined;
        rollbackLdif?: string | undefined;
    } | {
        url: string;
        binddn: string;
        bindpass: string;
        credentialType: LdapCredentialType.Static;
        rotationLdif: string;
        ca?: string | undefined;
    };
}>, z.ZodObject<{
    type: z.ZodLiteral<DynamicSecretProviders.Snowflake>;
    inputs: z.ZodObject<{
        accountId: z.ZodString;
        orgId: z.ZodString;
        username: z.ZodString;
        password: z.ZodString;
        creationStatement: z.ZodString;
        revocationStatement: z.ZodString;
        renewStatement: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        accountId: string;
        orgId: string;
        renewStatement?: string | undefined;
    }, {
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        accountId: string;
        orgId: string;
        renewStatement?: string | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    type: DynamicSecretProviders.Snowflake;
    inputs: {
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        accountId: string;
        orgId: string;
        renewStatement?: string | undefined;
    };
}, {
    type: DynamicSecretProviders.Snowflake;
    inputs: {
        username: string;
        password: string;
        creationStatement: string;
        revocationStatement: string;
        accountId: string;
        orgId: string;
        renewStatement?: string | undefined;
    };
}>, z.ZodObject<{
    type: z.ZodLiteral<DynamicSecretProviders.Totp>;
    inputs: z.ZodDiscriminatedUnion<"configType", [z.ZodObject<{
        configType: z.ZodLiteral<TotpConfigType.URL>;
        url: z.ZodEffects<z.ZodString, string, string>;
    }, "strip", z.ZodTypeAny, {
        url: string;
        configType: TotpConfigType.URL;
    }, {
        url: string;
        configType: TotpConfigType.URL;
    }>, z.ZodObject<{
        configType: z.ZodLiteral<TotpConfigType.MANUAL>;
        secret: z.ZodEffects<z.ZodString, string, string>;
        period: z.ZodOptional<z.ZodNumber>;
        algorithm: z.ZodOptional<z.ZodNativeEnum<typeof TotpAlgorithm>>;
        digits: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        configType: TotpConfigType.MANUAL;
        secret: string;
        period?: number | undefined;
        algorithm?: TotpAlgorithm | undefined;
        digits?: number | undefined;
    }, {
        configType: TotpConfigType.MANUAL;
        secret: string;
        period?: number | undefined;
        algorithm?: TotpAlgorithm | undefined;
        digits?: number | undefined;
    }>]>;
}, "strip", z.ZodTypeAny, {
    type: DynamicSecretProviders.Totp;
    inputs: {
        url: string;
        configType: TotpConfigType.URL;
    } | {
        configType: TotpConfigType.MANUAL;
        secret: string;
        period?: number | undefined;
        algorithm?: TotpAlgorithm | undefined;
        digits?: number | undefined;
    };
}, {
    type: DynamicSecretProviders.Totp;
    inputs: {
        url: string;
        configType: TotpConfigType.URL;
    } | {
        configType: TotpConfigType.MANUAL;
        secret: string;
        period?: number | undefined;
        algorithm?: TotpAlgorithm | undefined;
        digits?: number | undefined;
    };
}>]>;
type TDynamicSecretProvider = z.infer<typeof DynamicSecretProviderSchema>;

interface CreateDynamicSecretRequest {
    provider: TDynamicSecretProvider;
    defaultTTL: string;
    maxTTL: string;
    name: string;
    projectSlug: string;
    environmentSlug: string;
}
interface DynamicSecret {
    id: string;
    name: string;
    defaultTTL: string;
    maxTTL: string;
    provider: {
        type: DynamicSecretProviders;
        inputs: Record<string, any>;
    };
    createdAt: string;
    updatedAt: string;
    version: number;
    type: string;
    folderId: string;
    status: string;
    statusDetails: string;
    projectGatewayId: string;
    metadata: Record<string, any>;
}
interface CreateDynamicSecretResponse {
    dynamicSecret: DynamicSecret;
}
interface DeleteDynamicSecretRequest {
    environmentSlug: string;
    projectSlug: string;
    path?: string;
    isForced?: boolean;
}
interface DeleteDynamicSecretResponse {
    dynamicSecret: DynamicSecret;
}
interface CreateLeaseRequest {
    dynamicSecretName: string;
    environmentSlug: string;
    projectSlug: string;
    path?: string;
    ttl?: string;
}
interface Lease {
    id: string;
    dynamicSecretId: string;
    data: Record<string, any>;
    expiresAt: string;
    createdAt: string;
    updatedAt: string;
}
interface CreateLeaseResponse {
    lease: Lease;
}
interface DeleteLeaseRequest {
    environmentSlug: string;
    projectSlug: string;
    path?: string;
    isForced?: boolean;
}
interface DeleteLeaseResponse {
    lease: Lease;
}
interface RenewLeaseRequest {
    environmentSlug: string;
    projectSlug: string;
    path?: string;
    ttl?: string;
}
interface RenewLeaseResponse {
    lease: Lease;
}
type CreateDynamicSecretOptions = {
    provider: TDynamicSecretProvider;
    defaultTTL: string;
    maxTTL: string;
    name: string;
    projectSlug: string;
    environmentSlug: string;
    path?: string;
    metadata?: Record<string, any>;
};
type DeleteDynamicSecretOptions = {
    environmentSlug: string;
    projectSlug: string;
    path?: string;
    isForced?: boolean;
};
type CreateDynamicSecretLeaseOptions = {
    dynamicSecretName: string;
    environmentSlug: string;
    projectSlug: string;
    path?: string;
    ttl?: string;
};
type DeleteDynamicSecretLeaseOptions = {
    environmentSlug: string;
    projectSlug: string;
    path?: string;
    isForced?: boolean;
};
type RenewDynamicSecretLeaseOptions = {
    environmentSlug: string;
    projectSlug: string;
    path?: string;
    ttl?: string;
};

interface Environment {
    id: string;
    name: string;
    slug: string;
    position: number;
    projectId: string;
    createdAt: string;
    updatedAt: string;
}
interface CreateEnvironmentRequest {
    name: string;
    projectId: string;
    slug: string;
    position?: number;
}
type CreateEnvironmentResponse = {
    message: string;
    workspace: string;
    environment: Environment;
};
type CreateEnvironmentOptions = {
    name: string;
    projectId: string;
    slug: string;
    position?: number;
};

interface Project {
    id: string;
    name: string;
    slug: string;
    description?: string;
    type: string;
    createdAt: string;
    updatedAt: string;
}
interface CreateProjectRequest {
    projectName: string;
    type: string;
    projectDescription?: string;
    slug?: string;
    template?: string;
    kmsKeyId?: string;
}
interface CreateProjectResponse {
    project: Project;
}
interface InviteMembersRequest {
    projectId: string;
    emails?: string[];
    usernames?: string[];
    roleSlugs?: string[];
}
interface Membership {
    id: string;
    userId: string;
    projectId: string;
    role: string;
    status: string;
    createdAt: string;
    updatedAt: string;
}
interface InviteMembersResponse {
    memberships: Membership[];
}
type CreateProjectOptions = {
    projectName: string;
    type: string;
    projectDescription?: string;
    slug?: string;
    template?: string;
    kmsKeyId?: string;
};
type InviteMemberToProjectOptions = {
    projectId: string;
    emails?: string[];
    usernames?: string[];
    roleSlugs?: string[];
};

interface Folder {
    id: string;
    name: string;
    envId: string;
    description?: string;
    createdAt: string;
    updatedAt: string;
    parentId?: string;
    isReserved?: boolean;
    lastSecretModified?: string;
    version?: number;
}
interface CreateFolderRequest {
    name: string;
    path: string;
    workspaceId: string;
    environment: string;
    description?: string;
}
interface ListFoldersRequest {
    environment: string;
    workspaceId: string;
    path?: string;
    recursive?: boolean;
    lastSecretModified?: string;
}
interface CreateFolderResponse {
    folder: Folder;
}
interface ListFoldersResponse {
    folders: Folder[];
}
type CreateFolderOptions = {
    name: string;
    path: string;
    projectId: string;
    environment: string;
    description?: string;
};
type ListFoldersOptions = {
    environment: string;
    projectId: string;
    path?: string;
    recursive?: boolean;
    lastSecretModified?: string;
};

interface ApiResponse<T> {
    statusCode: number;
    message: string;
    data: T;
}
interface CreateSecretResponse {
    secret: Secret;
}
interface UpdateSecretResponse {
    secret: Secret;
}
interface DeleteSecretResponse {
    secret: Secret;
}

declare class SecretsApi {
    private apiClient;
    constructor(apiClient: ApiClient);
    listSecrets(params: ListSecretsRequest): Promise<ListSecretsResponse>;
    getSecret(params: GetSecretRequest): Promise<GetSecretResponse>;
    createSecret(secretName: string, data: CreateSecretRequest): Promise<CreateSecretResponse>;
    updateSecret(secretName: string, data: UpdateSecretRequest): Promise<UpdateSecretResponse>;
    deleteSecret(secretName: string, data: DeleteSecretRequest): Promise<DeleteSecretResponse>;
}

declare class SecretsClient {
    private apiClient;
    constructor(apiClient: SecretsApi);
    listSecrets: (options: ListSecretsOptions) => Promise<ListSecretsResponse>;
    listSecretsWithImports: (options: Omit<ListSecretsOptions, "includeImports">) => Promise<Secret[]>;
    getSecret: (options: GetSecretOptions) => Promise<Secret>;
    updateSecret: (secretName: string, options: UpdateSecretOptions) => Promise<UpdateSecretResponse>;
    createSecret: (secretName: string, options: CreateSecretOptions) => Promise<CreateSecretResponse>;
    deleteSecret: (secretName: string, options: DeleteSecretOptions) => Promise<DeleteSecretResponse>;
}

declare class AuthApi {
    private apiClient;
    constructor(apiClient: ApiClient);
    universalAuthLogin(data: UniversalAuthLoginRequest): Promise<UniversalAuthLoginResponse>;
    awsIamAuthLogin(data: AwsIamAuthLoginRequest): Promise<AwsIamAuthLoginResponse>;
    renewToken(data: TokenRenewRequest): Promise<TokenRenewResponse>;
}

type AuthenticatorFunction = (accessToken: string) => InfisicalSDK;
type AwsAuthLoginOptions = {
    identityId?: string;
};
declare class AuthClient {
    private sdkAuthenticator;
    private apiClient;
    private _accessToken?;
    constructor(sdkAuthenticator: AuthenticatorFunction, apiClient: AuthApi, _accessToken?: string | undefined);
    awsIamAuth: {
        login: (options?: AwsAuthLoginOptions) => Promise<InfisicalSDK>;
        renew: () => Promise<InfisicalSDK>;
    };
    universalAuth: {
        login: (options: UniversalAuthLoginRequest) => Promise<InfisicalSDK>;
        renew: () => Promise<InfisicalSDK>;
    };
    getAccessToken: () => string | null;
    accessToken: (token: string) => InfisicalSDK;
}

declare class DynamicSecretsApi {
    private apiClient;
    constructor(apiClient: ApiClient);
    create(data: CreateDynamicSecretRequest): Promise<CreateDynamicSecretResponse>;
    delete(secretName: string, data: DeleteDynamicSecretRequest): Promise<DeleteDynamicSecretResponse>;
    leases: {
        create: (data: CreateLeaseRequest) => Promise<CreateLeaseResponse>;
        delete: (leaseId: string, data: DeleteLeaseRequest) => Promise<DeleteLeaseResponse>;
        renew: (leaseId: string, data: RenewLeaseRequest) => Promise<RenewLeaseResponse>;
    };
}

declare class DynamicSecretsClient {
    private apiClient;
    constructor(apiClient: DynamicSecretsApi);
    create(options: CreateDynamicSecretOptions): Promise<DynamicSecret>;
    delete(dynamicSecretName: string, options: DeleteDynamicSecretOptions): Promise<DynamicSecret>;
    leases: {
        create: (options: CreateDynamicSecretLeaseOptions) => Promise<CreateLeaseResponse>;
        delete: (leaseId: string, options: DeleteDynamicSecretLeaseOptions) => Promise<DeleteLeaseResponse>;
        renew: (leaseId: string, options: RenewDynamicSecretLeaseOptions) => Promise<RenewLeaseResponse>;
    };
}

declare class EnvironmentsApi {
    private apiClient;
    constructor(apiClient: ApiClient);
    create(data: CreateEnvironmentRequest): Promise<CreateEnvironmentResponse>;
}

declare class EnvironmentsClient {
    private apiClient;
    constructor(apiClient: EnvironmentsApi);
    create: (options: CreateEnvironmentOptions) => Promise<Environment>;
}

declare class ProjectsApi {
    private apiClient;
    constructor(apiClient: ApiClient);
    create(data: CreateProjectRequest): Promise<CreateProjectResponse>;
    inviteMembers(data: InviteMembersRequest): Promise<InviteMembersResponse>;
}

declare class ProjectsClient {
    private apiClient;
    constructor(apiClient: ProjectsApi);
    create: (options: CreateProjectOptions) => Promise<Project>;
    inviteMembers: (options: InviteMemberToProjectOptions) => Promise<Membership[]>;
}

declare class FoldersApi {
    private apiClient;
    constructor(apiClient: ApiClient);
    create(data: CreateFolderRequest): Promise<CreateFolderResponse>;
    listFolders(queryParams: ListFoldersRequest): Promise<ListFoldersResponse>;
}

declare class FoldersClient {
    private apiClient;
    constructor(apiClient: FoldersApi);
    create: (options: CreateFolderOptions) => Promise<Folder>;
    listFolders: (options: ListFoldersOptions) => Promise<Folder[]>;
}

type InfisicalSDKOptions = {
    siteUrl?: string;
};
declare class InfisicalSDK {
    private apiClient;
    private authApi;
    private secretsApi;
    private dynamicSecretsApi;
    private environmentsApi;
    private projectsApi;
    private foldersApi;
    private authClient;
    private secretsClient;
    private dynamicSecretsClient;
    private environmentsClient;
    private projectsClient;
    private foldersClient;
    constructor(options?: InfisicalSDKOptions);
    private authenticate;
    secrets: () => SecretsClient;
    environments: () => EnvironmentsClient;
    projects: () => ProjectsClient;
    folders: () => FoldersClient;
    dynamicSecrets: () => DynamicSecretsClient;
    auth: () => AuthClient;
}

export { type ApiResponse, type AwsIamAuthLoginRequest, type AwsIamAuthLoginResponse, type BaseSecretOptions, type CreateDynamicSecretLeaseOptions, type CreateDynamicSecretOptions, type CreateDynamicSecretRequest, type CreateDynamicSecretResponse, type CreateEnvironmentOptions, type CreateEnvironmentRequest, type CreateEnvironmentResponse, type CreateFolderOptions, type CreateFolderRequest, type CreateFolderResponse, type CreateLeaseRequest, type CreateLeaseResponse, type CreateProjectOptions, type CreateProjectRequest, type CreateProjectResponse, type CreateSecretOptions, type CreateSecretRequest, type CreateSecretResponse, type DeleteDynamicSecretLeaseOptions, type DeleteDynamicSecretOptions, type DeleteDynamicSecretRequest, type DeleteDynamicSecretResponse, type DeleteLeaseRequest, type DeleteLeaseResponse, type DeleteSecretOptions, type DeleteSecretRequest, type DeleteSecretResponse, type DynamicSecret, DynamicSecretProviders, type Environment, type Folder, type GetSecretOptions, type GetSecretRequest, type GetSecretResponse, InfisicalSDK, type InviteMemberToProjectOptions, type InviteMembersRequest, type InviteMembersResponse, type Lease, type ListFoldersOptions, type ListFoldersRequest, type ListFoldersResponse, type ListSecretsOptions, type ListSecretsRequest, type ListSecretsResponse, type Membership, type Project, type RenewDynamicSecretLeaseOptions, type RenewLeaseRequest, type RenewLeaseResponse, type Secret, SecretType, SqlProviders, type TDynamicSecretProvider, type TokenRenewRequest, type TokenRenewResponse, type UniversalAuthLoginRequest, type UniversalAuthLoginResponse, type UpdateSecretOptions, type UpdateSecretRequest, type UpdateSecretResponse };
